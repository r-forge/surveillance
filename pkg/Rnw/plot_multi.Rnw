@

%create.disProg

\name{create.disProg}
\alias{create.disProg}
\encoding{latin1}

\title{Creating an object of class disProg}
\description{
  Creates an object of class \code{disProg} from a vector with the weeknumber
  (week) and matrices with the observed number of counts (observed) and the
  respective state chains (state), where each column represents an individual
  time series. The matrices neighbourhood and populationFrac provide 
  information about neighbouring units and population proportions.
}
\usage{
  create.disProg(week, observed, state, start=c(2001,1), freq=52, 
  neighbourhood=NULL, populationFrac=NULL)
}
\arguments{
\item{week}{number of week}
\item{observed}{matrix with parallel time series of counts where rows are 
    time points and columns are the individual time series for unit/area
    \eqn{i, i=1,\ldots,m}}
\item{state}{matrix with corresponding states}
\item{start}{vector of length two denoting the year and the sample number (week, month, etc.) of the first observation}
\item{freq}{sampling frequency per year, i.e. 52 for weekly data, 12 for monthly data, 13 if 52 weeks are aggregated into 4 week blocks.}
\item{neighbourhood}{neighbourhood matrix \eqn{N} of dimension 
    \eqn{m \times m} with elements \eqn{n_{ij}=1} if units \eqn{i}
    and \eqn{j} are adjacent and 0 otherwise } 
\item{populationFrac}{matrix with corresponding population proportions} 
}
\value{\item{disProg}{object of class \code{disProg}  
  }
}
\details{}
\seealso{}
\author{M. Paul}
\examples{

  # create an univariate disProg object for the salmonella.agona data
  data(salmonella.agona)
  week <- nrow(salmonella.agona)
  salmonellaDisProg <- create.disProg(week=week, observed=salmonella.agona$observed,
  state=salmonella.agona$state)
  
  # plot salmonella cases
  title <- "Salmonella Agona cases in the UK"
  plot(salmonellaDisProg, title = title, xaxis.years=TRUE, legend=FALSE,
        startyear = 1990, firstweek = 1)
}
\keyword{}


<<echo=FALSE>>=
create.disProg <- function(week, observed, state, start=c(2001,1), freq=52, neighbourhood=NULL, populationFrac=NULL){
  namesObs <-colnames(observed)
  namesState <- colnames(observed)
  
  #univariate timeseries ?
  if(is.vector(observed))
    observed <- matrix(observed,ncol=1)
  if(is.vector(state))
    state <- matrix(state,ncol=1)
    
  #check number of columns of observed and state
  nAreas <- ncol(observed)
  nObs <- nrow(observed)
  if(ncol(observed) != ncol(state)){
    #if there is only one state-vector for more than one area, repeat it
    if(ncol(state)==1)
      state <- matrix(rep(state,nAreas),ncol=nAreas,byrow=FALSE)
    else{ 
      cat('wrong dimensions of observed and state \n')
      return(NULL)
    }
  }
  
  #check neighbourhood matrix
  if(!is.null(neighbourhood) & (any(dim(neighbourhood) != nAreas))) {
    cat('wrong dimensions of neighbourhood matrix \n')
    return(NULL)
  }
  
  #if(is.null(populationFrac)) 
  #
  if (nAreas ==1){
    populationFrac <- matrix(1,nrow=nObs, ncol=1)
  } 
  #if(is.null(neighbourhood) & (nAreas >1) )
  #  
  
  #labels for observed and state
  if(is.null(namesObs)){
    namesObs <- paste("observed", 1:nAreas, sep="")       
    namesState <- paste("state", 1:nAreas, sep="")  
  }
 
  dimnames(observed) <- list(NULL,namesObs)
  dimnames(state) <- list(NULL,namesState)
  
  res <- list("week"=week, "observed"=observed, "state"=state, "start"=start, "freq"=freq,  "neighbourhood"=neighbourhood, "populationFrac"=populationFrac)
  class(res) <- "disProg"
  return(res)
}
@

% sumNeighbours
\name{sumNeighbours}
\alias{sumNeighbours}
\title{Calculates the sum of counts of adjacent areas}
\description{
       Calculates the sum of counts of adjacent units/areas, i.e.
       \eqn{\sum_{j \sim i} y_{j,t}} for all time points \eqn{t} and 
       each unit \eqn{i}, \eqn{t=1,\ldots,n, i=1,\ldots,m}.
}
\usage{
  sumNeighbours(disProgObj)
}
\arguments{
        \item{disProgObj}{Object of class \code{disProg}}
}
\value{matrix of dimension \eqn{n \times m}}
}
\keyword{}

<<echo=FALSE>>=
sumNeighbours <- function(disProgObj){

  observed <- disProgObj$observed
  neighbours <- matrix(nrow=nrow(observed),ncol=ncol(observed))
    
  for(i in 1:ncol(observed)){
    #only one neighbour
    if(sum(disProgObj$neighbourhood[,i])==1)
      neighbours[,i] <- observed[,disProgObj$neighbourhood[,i]==1]
    #more than one neighbour
    else
      neighbours[,i] <- apply(observed[,disProgObj$neighbourhood[,i]==1], MAR=1, sum)
  }
  return(neighbours)
}
@

% aggregate.disProg
\name{aggregate.disProg}
\alias{aggregate.disProg}
\title{Aggregate the observed counts}
\description{
       Aggregates the observed counts for a multivariate
       \code{disProgObj} over the units. Future versions 
       of \code{surveillance} will also allow for time aggregations etc. 
}
\usage{
  aggregate.disProg(x,...)
}
\arguments{
        \item{x}{Object of class \code{disProg}}
        \item{...}{not used at the moment}
}
\value{\item{x}{univariate \code{disProg} object with aggregated 
     counts and respective states for each time point.}
}
\keyword{}
\examples{
data(ha)
plot(aggregate(ha))
}

<<echo=FALSE>>=
aggregate.disProg <- function(x,...){
  #aggregate observed counts
  observed <- apply(x$observed,MAR=1,sum)
  #aggregate states
  state <- apply(x$state,MAR=1,sum)
  state[state > 1] <- 1
  
  #create univariate disProg object
  x <- create.disProg(week=x$week, observed=observed, state=state, freq=x$freq)
  return(x)
}
@

% plot.disProg
\name{plot.disProg}
\alias{plot.disProg}
\alias{plot.disProg.one}
\encoding{latin1}

\title{Plot Generation of the Observed and the defined Outbreak States of a 
  (multivariate) time series}
\description{Plotting of a disProg object.
}
\usage{
  plot.disProg(x, title = "", xaxis.years=TRUE, startyear = 2001, firstweek = 1, as.one=TRUE, same.scale=TRUE, ...)
  plot.disProg.one(x, title = "", xaxis.years=TRUE, startyear = 2001, firstweek = 1, ylim=NULL, xlab="time", ylab="No. infected",type="hh",lty=c(1,1),col=c(1,1), outbreak.symbol = list(pch=3, col=3), legend.opts=list(x="top", legend=c("Infected", "Outbreak"),lty=NULL,pch=NULL,col=NULL), ...)
}
\arguments{
        \item{x}{Object of class \code{disProg}}
        \item{title}{Plot title}
        \item{xaxis.years}{if \code{TRUE}, the x axis is labeled using years}
        \item{startyear}{Year to begin the axis labeling (the year where
                the oldest data come from). This arguments will be obsolete in \code{sts}.}
        \item{firstweek}{Number of the first week of January in the first year 
                (just for axis labeling grounds)}
        \item{as.one}{if \code{TRUE} all individual time series are shown in 
              one plot}
        \item{same.scale}{if \code{TRUE} all plots have same scale}
        \item{ylim}{range of y axis}
        \item{xlab}{label of the x-axis}
        \item{ylab}{label of the y-axis}
        \item{type}{line type of the observed counts (should be \code{hh})}
        \item{lty}{line type of the observed counts}
        \item{col}{color of the observed count lines}
        \item{outbreak.symbol}{list with entries \code{pch} and \code{col} specifying the plot symbol}
        \item{legend.opts}{a list containing the entries to be sent to the \code{\link{legend}} function. If no legend is requested use \code{legend.opts=NULL}. Otherwise, the following arguments are default
            \describe{
            \item{x}{\code{top}}
            \item{legend}{The names infected and outbreak.}
            \item{lty}{If \code{NULL} the \code{lty} argument will be used.}
            \item{pch}{If \code{NULL} the \code{pch} argument is used.}
            \item{col}{If \code{NULL} the \code{col} argument is
                used.}  
            }
            
            An further arguments to the \code{legend} function are
            just provided as additional elements of this list,
            e.g. \code{horiz=TRUE}.  
          }
        \item{...}{further arguments for the function \code{matplot}.}
}
\value{
        \item{a plot}{showing the number of infected and the defined alarm status
                for a time series created by simulation or given in data 
                either in one single plot or in several plots for each individual
                time series. }
}
\author{M. Höhle with contributions by A. Riebler and C. Lang}
\examples{

    # Plotting of simulated data
    disProgObj <- sim.pointSource(p = 0.99, r = 0.5, length = 208,
                                    A = 1, alpha = 1, beta = 0, phi = 0,
                                    frequency = 1, state = NULL, K = 5)
    # plot the simulated disease with the defined outbreaks
    plot(disProgObj)
    title <- "Number of Infected and Defined Outbreak Positions for Simulated Data"
    plot(disProgObj, title = title)
    plot(disProgObj, title = title, xaxis.years=TRUE,
            startyear = 1999, firstweek = 13)
    plot(disProgObj, title = title, xaxis.years=TRUE,
            startyear = 1999, firstweek = 14)
    
    # Plotting of measels data
    data(measels.weser)
    # one plot
    plot(measels.weser, title = "measels cases in the district Weser-Ems",
            xaxis.years=TRUE, startyear= 2001, firstweek=1)
    # plot cases for each "Kreis" 
    plot(measels.weser, same.scale=TRUE, as.one=FALSE)
}

\keyword{}

<<echo=FALSE>>=

plot.disProg.one <- function(x, title = "", xaxis.years=TRUE, startyear = 2001, firstweek = 1, ylim=NULL, xlab="time", ylab="No. infected",type="hh",lty=c(1,1),col=c(1,1), outbreak.symbol = list(pch=3, col=3),legend.opts=list(x="top", legend=c("Infected", "Outbreak"),lty=NULL,pch=NULL,col=NULL), ...) {


  observed <- x$observed
  state    <- x$state

  # width of the column
  tab <- 0.5

  # left/right help for constructing the columns
  observedxl <- (1:length(observed))-tab
  observedxr <- (1:length(observed))+tab
        
  # control where the highest value is
  max <- max(observed)
        
  #if ylim is not specified
  if(is.null(ylim)){
    ylim <- c(-1/20*max, max)
  }

  #Plot the results using one Large plot call
  matplot(x=cbind(observedxl, observedxr),y=cbind(observed, observed),xlab=xlab,ylab=ylab,
          type=type,lty=lty, col=col, ylim=ylim,axes = !(xaxis.years),...)
  
  #Show the outbreaks
  if (!is.null(outbreak.symbol)) {
    for(i in 1:length(observed)){
      matlines( c(i-tab, i+tab), c(observed[i],observed[i]) )
      if(state[i] == 1)
        matpoints( i, ylim[1], pch=outbreak.symbol$pch, col=outbreak.symbol$col)
    }
  }
        
  title(title)
  cex <- par()$cex.axis
        
  #Label of x-axis 
  if(xaxis.years){        
    # get the number of quarters lying in range for getting the year and quarter order
    myat.week <- seq(ceiling((52-firstweek+1)/13) * 13 + 1, length(observed)+(floor((52-firstweek + 1)/13) * 13 +1), by=13)
    # get the right year order
    year <- (myat.week - 52) %/% 52 + startyear
    # function to define the quarter order
    quarterFunc <- function(i) { switch(i+1,"I","II","III","IV")}
    # get the right number and order of quarter labels
    quarter <- sapply( (myat.week-1) %/% 13 %% 4, quarterFunc)
    # get the positions for the axis labels
    myat.week <- myat.week - (52 - firstweek + 1)

    # construct the computed axis labels
    if (cex == 1) {
      mylabels.week <- paste(year,"\n\n",quarter,sep="")
    } else {
      mylabels.week <- paste(year,"\n",quarter,sep="")
    }
        
    axis( at=myat.week , labels=mylabels.week , side=1, line = 1 )
    axis( side=2 )
  }
        
  #should there be a legend? 
  if(!is.null(legend.opts)) {
    #Fill empty (mandatory) slots in legend.opts list
    if (is.null(legend.opts$lty)) legend.opts$lty = c(lty[1],NA)
    if (is.null(legend.opts$col)) legend.opts$col = c(col[1],outbreak.symbol$col)
    if (is.null(legend.opts$pch)) legend.opts$pch = c(NA,outbreak.symbol$pch)
    if (is.null(legend.opts$x))   legend.opts$x = "top"
    if (is.null(legend.opts$legend)) legend.opts$legend = c("Infected", "Outbreak")

    #Create the legend
    do.call("legend",legend.opts)
  }
  
  invisible()
}

plot.disProg <- function(x, title = "", xaxis.years=TRUE, startyear = 2001, firstweek = 1, as.one=TRUE, same.scale=TRUE, ...){
  observed <- x$observed
  state    <- x$state
  
  #univariate timeseries ?
  if(is.vector(observed))
    observed <- matrix(observed,ncol=1)
  if(is.vector(state))
    state <- matrix(state,ncol=1)
  
  nAreas <- ncol(observed)
  max <- max(observed)
  
  #check if x is multivariate or univariate 
  
  #multivariate time series
  if(nAreas > 1){
    #all areas in one plot -- not supported in sts
    if(as.one){
      matplot(observed,type="l",lty=1:nAreas,col=1:nAreas,ylim=c(0, 1.1*max),xlab="time",ylab="No. of Infected", axes=!xaxis.years)
      #If no legend.opts is specified or not set to null
      if ((is.na(pmatch("legend.opts",names(list(...))))) | 
          (!is.na(pmatch("legend.opts",names(list(...)))) & (!is.null(list(...)$legend.opts)))) {
        legend.opts <- list(...)$legend.opts
        if (is.null(legend.opts$x)) legend.opts$x = "topleft"
        if (is.null(legend.opts$legend)) legend.opts$legend = colnames(observed)
        if (is.null(legend.opts$col)) legend.opts$col = 1:nAreas
        if (is.null(legend.opts$lty)) legend.opts$lty = 1:nAreas
        if (is.null(legend.opts$ncol)) legend.opts$ncol = 5
        if (is.null(legend.opts$bty)) legend.opts$bty = "n"

        do.call("legend",legend.opts)
      }

      title(title)
      
      if(xaxis.years){  #todo: move this as output of ONE function
          # get the number of quarters lying in range for getting the year and quarter order
          myat.week <- seq(ceiling((52-firstweek+1)/13) * 13 + 1, length(observed)+(floor((52-firstweek + 1)/13) * 13 +1), by=13)
          # get the right year order
          year <- (myat.week - 52) %/% 52 + startyear
          # function to define the quarter order
          quarterFunc <- function(i) { switch(i+1,"I","II","III","IV")}
          # get the right number and order of quarter labels
          quarter <- sapply( (myat.week-1) %/% 13 %% 4, quarterFunc)
          # get the positions for the axis labels
          myat.week <- myat.week - (52 - firstweek + 1)

          # construct the computed axis labels
          cex <- par()$cex.axis
          if (cex == 1) {
            mylabels.week <- paste(year,"\n\n",quarter,sep="")
          } else {
            mylabels.week <- paste(year,"\n",quarter,sep="")
          }
        
          axis( at=myat.week , labels=mylabels.week , side=1, line = 1 )
          axis( side=2 )
       }
      
    } else {  #plot each area
      #set window size     
      par(mfrow=magic.dim(nAreas),mar=c(2,1,1,1))
      
      if(same.scale)
        ylim <- c(-1/20*max, max)
      else
        ylim <- NULL
      
      #plot areas
      k <- 1:nAreas
      sapply(k, function(k) {
         plot.disProg.one(create.disProg(x$week, observed[,k], state[,k]), 
                          title = "", startyear = startyear, firstweek = firstweek, 
                          xaxis.years=xaxis.years, ylim=ylim, legend.opts=NULL, ... )   
         mtext(colnames(observed)[k],line=-1.3)     
         })
      #reset graphical params
      par(mfrow=c(1,1), mar=c(5, 4, 4, 2)+0.1)
    }
  } else {  #univariate time series
    plot.disProg.one(x=x, title = title, startyear = startyear, firstweek = firstweek, xaxis.years=xaxis.years, ...)
  }
  invisible()
}
@



\name{plot.survRes}
\alias{plot.survRes}
\alias{plot.survRes.one}
\encoding{latin1}

\title{Plot a survRes object}
\description{Plotting of a (multivariate) \code{survRes} object. The function \code{plot.survRes.one} is used as a helper function to plot a univariate time series.}
}
\usage{
  plot.survRes(x, method=x$control$name, disease=x$control$data, xaxis.years=TRUE,startyear = 2001, firstweek = 1, same.scale=TRUE,...)
  plot.survRes.one(x, method=x$control$name, disease=x$control$data, domany=FALSE,ylim=NULL,xaxis.years=TRUE,startyear = 2001, firstweek = 1, xlab="time", ylab="No. infected", main=NULL, type="hhs",lty=c(1,1,2),col=c(1,1,4), outbreak.symbol = list(pch=3, col=3),alarm.symbol=list(pch=24, col=2),legend.opts=list(x="top",legend=c("Infected", "Threshold", "Alarm", "Outbreak"),lty=NULL,col=NULL,pch=NULL), ...)
}
\arguments{
        \item{x}{Object of class \code{survRes}}
        \item{method}{Surveillance method to be used in title}
        \item{disease}{Name of disease in title}
        \item{xaxis.years}{Boolean indicating whether to show a year based x-axis for weekly data} 
        \item{domany}{Boolean telling the function whether it is called for a multivariate (\code{TRUE}) or univariate (\code{FALSE}) \code{survRes} object. In case of \code{TRUE} no titles are drawn.}
        \item{ylim}{range of y axis}
        \item{startyear}{Year to begin the axis labeling (the year where
                the oldest data come from)}
        \item{firstweek}{Number of the first week of January in the first year (just for axis labeling reasons)}
        \item{xlab}{label of the x-axis}
        \item{ylab}{label of the y-axis}
        \item{main}{The title of the graphics is generated from the \code{method} and \code{disease} arguments if not specified otherwise}
        \item{same.scale}{Plot all time series with the same \code{ylim}? Defaults to \code{true}}.
        \item{type}{line type of the observed counts (first two elements) and the upper bound (third element)}
        \item{lty}{vector of size 3 speciying the line type of the observed counts (left, right) and the upperbound line}
        \item{col}{vector with three elements: color of left bar and color of top bar, color of right bar, col of the upperbound line.}
        \item{outbreak.symbol}{list with entries \code{pch} and \code{col} specifying the plot symbol}
        \item{alarm.symbol}{list with entries \code{pch} and \code{col} specifying the plot symbol}
        \item{legend.opts}{a list containing the entries to be sent to the \code{\link{legend}} function. If no legend is requested use \code{legend.opts=NULL}. Otherwise, the following arguments are default
            \describe{
            \item{x}{\code{top}}
            \item{legend}{The names infected and outbreak.}
            \item{lty}{If \code{NULL} the \code{lty} argument will be used.}
            \item{pch}{If \code{NULL} the \code{pch} argument is used.}
            \item{col}{If \code{NULL} the \code{col} argument is
                used.}  
            }
            
            An further arguments to the \code{legend} function are
            just provided as additional elements of this list,
            e.g. \code{horiz=TRUE}.  
          }
        \item{...}{further arguments for the function \code{matplot}. If e.g. \code{xlab} or \code{main} are provided they overwrite the default values.}
}
\value{
  none. A plot showing the number of infected, the threshold for recognizing an
  outbreak, the alarm status and the outbreak status is generated.
}
\details{
  The \code{plot.survRes.one} is intended for internal use. At the moment none of the surveillance methods support multivariate \code{survRes} objects. New versions of the packages currently under development will handle this.
}
\author{M. Höhle}
\examples{
data(ha)
ctrl <- list(range = 209:290, b = 2, w = 6, alpha = 0.005)
plot(algo.bayes(aggregate(ha), control = ctrl))
}

\keyword{}

<<echo=F>>=

plot.survRes.one <- function(x, method=x$control$name, disease=x$control$data, domany=FALSE,ylim=NULL,xaxis.years=TRUE,startyear = 2001, firstweek = 1, xlab="time", ylab="No. infected", main=NULL, type="hhs",lty=c(1,1,2),col=c(1,1,4), outbreak.symbol = list(pch=3, col=3),alarm.symbol=list(pch=24, col=2),legend.opts=list(x="top",legend=c("Infected", "Threshold", "Alarm", "Outbreak"),lty=NULL,col=NULL,pch=NULL), ...) {

  ################## Handle the NULL arguments ########################################################
  if (is.null(main)) main = paste("Analysis of ", as.character(disease), " using ", as.character(method),sep="") 
  #No titles are drawn when more than one is plotted.
  if (domany) main = ""

  survResObj <- x
  observed <- survResObj$disProgObj$observed[survResObj$control$range]
  state    <- survResObj$disProgObj$state[survResObj$control$range]
        
  #print(list(...))
  # width of the column
  tab <- 0.5

  # left/right help for constructing the columns
  observedxl <- (1:length(observed))-tab 
  observedxr <- (1:length(observed))+tab
  upperboundx <- (1:length(survResObj$upperbound)) #-0.5 
  
  # control where the highest value is
  max <- max(max(observed),max(survResObj$upperbound))
  
  #if ylim is not specified
  #if(is.null(ylim)){
  #  ylim <- c(-1/20*max, max)
  #}

#~~~~~~~~~~~~~~~~~~~~~~~~~~
  if (is.null(ylim)) {
    max <- max(max(observed), max(survResObj$upperbound))
    ylim <- c(-1/20 * max, max)
  } else
  max <- ylim[2]
  
  #ensure that there is enough space for the alarm/outbreak symbols   
  if(ylim[1]>=0)
    ylim[1] <- -1/20*max
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    

  #Generate the matrices to plot
  xstuff <- cbind(observedxl, observedxr, upperboundx) #no adjusting + min(x$control$range) - 1
  ystuff <- cbind(observed, observed, survResObj$upperbound)
        

  #Plot the results using one Large plot call (we do this by modifying
  #the call). 
  matplot(x=xstuff,y=ystuff,xlab=xlab,ylab=ylab,main=main,ylim=ylim,axes = !(xaxis.years),type=type,lty=lty,col=col,...)

  
  if (!is.null(survResObj$aggr)) {
    points(upperboundx+tab,survResObj$aggr,col=1)
  }
  
  for(i in 1:length(observed)){
    matlines( c(i-tab, i+tab), c(observed[i],observed[i]),col=col[1])
    if(survResObj$alarm[i] == 1)
      matpoints( i, -1/40*max, pch=alarm.symbol$pch, col=alarm.symbol$col)
    if(state[i] == 1)
      matpoints( i, -1/20*max, pch=outbreak.symbol$pch, col=outbreak.symbol$col)
  }

  # check where to place the legend. If the left upper side is free place it there
  if (max * 2/3 >= max(
                max(observed[1:floor(1/4 * length(observed))]),
                max(survResObj$upperbound[1:floor(1/4 * length(survResObj$upperbound))])
                )) {
    xlegpos <- 0
  }

  #Label of x-axis 
  if(xaxis.years){        
    # get the number of quarters lying in range for getting the year and quarter order
    myat.week <- seq(ceiling((52-firstweek+1)/13) * 13 + 1, length(observed)+(floor((52-firstweek + 1)/13) * 13 +1), by=13)
    # get the right year order
    year <- (myat.week - 52) %/% 52 + startyear
    # function to define the quarter order
    quarterFunc <- function(i) { switch(i+1,"I","II","III","IV")}
    # get the right number and order of quarter labels
    quarter <- sapply( (myat.week-1) %/% 13 %% 4, quarterFunc)
    # get the positions for the axis labels
    myat.week <- myat.week - (52 - firstweek + 1)

    # construct the computed axis labels
    #cex <- par()$cex.axis
    #if (cex == 1) {
    mylabels.week <- paste(year,"\n\n",quarter,sep="")
    #} else {
    #  mylabels.week <- paste(year,"\n",quarter,sep="")
    #}
    
    axis( at=myat.week , labels=mylabels.week , side=1, line = 1 )
    axis( side=2 )
  }
  
  if(!is.null(legend.opts)) {
    #Fill empty (mandatory) slots in legend.opts list
    if (is.null(legend.opts$lty)) legend.opts$lty = c(lty[1],lty[3],NA,NA)
    if (is.null(legend.opts$col)) legend.opts$col = c(col[1],col[3],alarm.symbol$col,outbreak.symbol$col)
    if (is.null(legend.opts$pch)) legend.opts$pch = c(NA,NA,alarm.symbol$pch,outbreak.symbol$pch)
    if (is.null(legend.opts$x))   legend.opts$x = "top"
    if (is.null(legend.opts$legend)) 
      legend.opts$legend = c("Infected", "Threshold", "Alarm", "Outbreak")

    do.call("legend",legend.opts)
  }
  
  
  invisible()
}


#the main function -- cant we do better than this?
plot.survRes <- function(x, method=x$control$name, disease=x$control$data, xaxis.years=TRUE,startyear = 2001, firstweek = 1, same.scale=TRUE,...) {
  observed <- x$disProgObj$observed
  state <- x$disProgObj$state
  alarm <- x$alarm
  
  #univariate timeseries ?
  if(is.vector(observed))
    observed <- matrix(observed,ncol=1)
  if(is.vector(state))
    state <- matrix(state,ncol=1)
  if(is.vector(alarm)) 
    alarm <- matrix(alarm,ncol=1)
  nAreas <- ncol(observed)
  max <-  max(max(observed),max(x$upperbound))

  #multivariate time series
  if(nAreas > 1){
    #all areas in one plot 
      #set window size     
      par(mfrow=magic.dim(nAreas),mar=c(2,1,1,1))
      
      if(same.scale) {
        ylim <- c(-1/20*max, max)
      } else {
        ylim <- NULL
      }
      
      #plot areas
      k <- 1:nAreas
      sapply(k, function(k) {
        #Create the survRes
        dP <- create.disProg(x$disProgObj$week, observed[,k], state[,k])
        obj <- list(alarm=alarm[,k],disProgObj=dP,control=x$control,upperbound=x$upperbound[,k])
        class(obj) <- "survRes"
        plot.survRes.one(obj,startyear = startyear, firstweek = firstweek, 
                         xaxis.years=xaxis.years, ylim=ylim, legend.opts=NULL,domany=TRUE,... )   
         mtext(colnames(observed)[k],line=-1.3)     
         })
      #reset graphical params
      par(mfrow=c(1,1), mar=c(5, 4, 4, 2)+0.1)
    }
  else {  #univariate time series
    plot.survRes.one(x=x, startyear = startyear, firstweek = firstweek, xaxis.years=xaxis.years, domany=FALSE,...)
  }
  invisible()
}

@













% magic.dim
\name{magic.dim}
\alias{magic.dim}
\encoding{latin1}

\title{Returns a suitable k1 x k2 for plotting the disProgObj}
\description{
       For a given number k \code{magic.dim} provides a vector 
       containing two elements nRows and nCols which can be used to set the 
       dimension of a single graphic device so that nRow*nCol plots can be 
       drawn by row (or by column) on the device.
}
\usage{
      magic.dim(k)
}
\arguments{
      \item{k}{an integer}
}
\value{vector with two elements}
\keyword{}

<<echo=FALSE>>=
magic.dim <- function(k){
  if(k==1)
    return(c(1,1))
  
  #factorize k  
  factors <- primeFactors(k)
  
  #find the best factorization of k into two factors
  res <- bestCombination(factors)
    
  #if k is a prime or the difference between the two factors of k is too large
  #rather use the roots of the next square number greater than k 
  
  #up is root of the smallest square number >= k
  up <- ceiling(sqrt(k))
  #low is root of the biggest square number < k
  low <- up -1
  
  if(diff(res) >5){
    # e.g. k=11 is a prime, the next square number is 16 so up=4 and low=3
    # low^2 = 9 < 11 is naturally too small, up^2=16 > 11 so c(4,4) is a solution
    # but low*up = 3*4 = 12 > 11 is also adequate and a better solution
    if((k - low^2) < up)
      res <- c(low,up)
    else
      res <- c(up,up)
  }  
  
  return(sort(res))
  
}
@

% primeFactors
\name{primeFactors}
\alias{primeFactors}
\encoding{latin1}

\title{Prime number factorization}
\description{
       Computes prime number factorization of an integer x. 
}
\usage{
      primeFactors(x)
}
\arguments{
      \item{x}{an integer}
}
\value{vector with prime number factorization of x}
\keyword{}

<<echo=FALSE>>=
primeFactors <- function(x){
  if(x==1)
    return(1)
    
  factors<- numeric(0)  
  i<-1
  
  #start with i=2 and divide x by i (as often as possible) then try division by i+1
  #until all factors are found, i.e. x=1 
  while(i < x){
    i <- i+1   
    
    while((x %% i)==0){
      # each time a new factor i is found, save it and proceed with x = x/i 
      # e.g. k=20: 2 is a factor of x=20, continue with x = 10 = 20/2  
      #            2 is a factor of x=10, continue with x = 5 = 10/2
      #            3 and 4 are no factors of x = 5   
      #            5 is a factor of x = 5, continue with x = 1 
      # result: 20 = c(2, 2, 5)
      factors <- c(factors, i)
      x <- x/i
    }
  }
  return(factors)
}
@

% bestCombination
\name{bestCombination}
\alias{bestCombination}
\encoding{latin1}

\title{Partition of a number into two factors}
\description{
       Given a prime number factorization \code{x}, \code{best combination}
       partitions \code{x} into two groups, such that the product of the numbers
       in group one is as similar as possible to the product
       of the numbers of group two. This is useful in magic.dim 
}
\usage{
      bestCombination(x)
}
\arguments{
      \item{x}{prime number factorization}
}
\value{Returns a vector c(prod(set1),prod(set2))
      }
\keyword{}
<<echo=FALSE>>=
######################################################################
# Given a prime number factorization of a number, e.g. 36
# yields x=c(2,2,3,3)
# and parition x into two groups, such that the product of the numbers
# in group one is as similar as possible to the product
# of the numbers of group two. This is useful in magic.dim
#
# Params:
#  x - the prime number factorization
#
# Returns:
#  c(prod(set1),prod(set2))
######################################################################

bestCombination <- function(x) {
  #Compute the power set of 0:1^length(x), i.e. a binary indicator for
  #variable stating whether to include it in set 1 or not.
  combos <- as.matrix(expand.grid(rep(list(0:1),length(x))))
  mode(combos) <- "logical"
  
  #Small helper function, given a vector of length(x) stating whether
  #to include an element in set1 or not, compute the product
  #of set1 and set2=x\backslash set1
  #set1: all those for which include is TRUE, set2: all those for which
  #include is FALSE
  setsize <- function(include) { c(prod(x[include]),prod(x[!include])) }

  #Compute the product of set1 and set2 for each possible combination
  sizes <- apply(combos,MARGIN=1,FUN=setsize)
  #Calculate the combination, where x is as close to y as possible
  bestConfig <- combos[which.min(abs(diff(sizes))),]
  #Return this setsize of this configuration
  return(setsize(bestConfig))
}


