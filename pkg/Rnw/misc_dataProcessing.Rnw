@

\name{readData}
\alias{readData}
\title{Reading of Disease Data}
\description{Reading of disease data. In the package disease data are saved in a file \code{<abb>.txt} containing three columns -- the weeknumber (week), the observed number of counts (observed) and a state (state). The data are read using \code{read.table(...,header=T)}, hence the file has to contain a header.

}
\usage{
    readData(abb,week53to52=TRUE,sysPath=TRUE)
}
\arguments{
        \item{abb}{abbreviation of the diseasename.}
        \item{week53to52}{Boolean indicating whether to convert RKI 53 Weeks System to 52 weeks a year} 
          \item{sysPath}{Boolean, if \code{TRUE} then R automatically looks in the data directory of the surveillance package.}
}
\value{
        \item{disProg}{a object \code{disProg} (disease progress) including a list of the observed and the state chain.}
}
\details{
  This function is only kept for backwards compability. As of 0.9-2 all data should be read with \code{data}.
}
\seealso{\code{\link{m1}}, \code{\link{m2}}, \code{\link{m3}}, \code{\link{m4}}, \code{\link{m5}},
        \code{\link{q1_nrwh}}, \code{\link{q2}}, \code{\link{s1}}, \code{\link{s2}}, \code{\link{s3}},
        \code{\link{k1}}, \code{\link{n1}}, \code{\link{n2}}, \code{\link{h1_nrwrp}}
}
\examples{
    readData("m5")

    #To bring a single vector of counts into a format, which can be
    #handled by readData. Assume ``counts'' is a vector of counts.
    counts <- rpois(100,20)
    counts <- data.frame("week"=1:length(counts),"observed"=counts,"state"=rep(0,length(counts)))
    write(c("week","observed","state"),file="disease.txt",ncol=3)
    write(t(as.matrix(counts)),file="disease.txt",ncol=3,append=TRUE)
    disease <- readData("disease",week53to52=FALSE,sysPath=FALSE)

}

%\keyword{}

<<echo=F>>=



# 'readData' to reads the data of a specified disease of several years
#       and generates a state chain using the bulletin knowledge
#
# Parameter:
#       abb : abbreviation of the disease
#       week53to52: Boolean indicating whether to convert RKI 53 Weeks System to 52 weeks a year
readData <- function(abb,week53to52=TRUE,sysPath=TRUE){
  #Read depending on which path is requested
  if (sysPath) {
    #Prepend the systempath/data to the filename
    file <- file.path(.path.package('surveillance'),'data',paste(abb,".txt",sep=""))
  } else {
    file <- file.path(paste(abb,".txt",sep=""))
  }

  # read the data from four years and write it to a table
  #file <- paste( dataPath, abb , ".txt" , sep="" )
  fileTable <- read.table( file=file, header=TRUE )
  observed <- fileTable$observed
  state <- fileTable$state
  
  result = list(observed=observed, state=state)
  
  class(result) = "disProg" # for disease progress
  
  #Convert to 52 week system...
  if (week53to52) {
    result <- correct53to52(result)
  }
  
  result$freq <- 52
  result$start <- c(2001,1)
  
  return(result)
}


@

\name{toFileDisProg}
\alias{toFileDisProg}
\title{Writing of Disease Data}
\description{Writing of disease data (disProg object) into a file.
}
\usage{
    toFileDisProg(disProgObj, toFile)
}
\arguments{
        \item{disProgObj}{The disProgObj to save in file}
        \item{toFile}{The path and filename of the file to save}
}
\value{
        \item{file}{The file with the disease data}
}
\details{
  Writing of \code{disProg} object into a file as illustrated in the example.
}
\seealso{\code{\link{readData}}, \code{\link{sim.pointSource}}}
\examples{
    disProgObj <- sim.pointSource(length=200, K=1)
    toFileDisProg(disProgObj, "./simulation.txt")
    mydisProgObj <- readData("./simulation",sysPath=FALSE)
}

%\keyword{}

<<echo=F>>=

toFileDisProg <- function(disProgObj, toFile){

        length <- length(disProgObj$observed)

        writeMatrix <- matrix(0, length, 3)
        dimnames(writeMatrix) <- list(c(), c("week", "observed", "state"))

        writeMatrix[,"week"] <- 1:length
        writeMatrix[,"observed"] <- disProgObj$observed
        writeMatrix[,"state"] <- disProgObj$state

        write.table(writeMatrix, toFile, row.names = FALSE, sep = "\t")
}


@

\name{correct53to52}
\alias{correct53to52}
\title{Data Correction from 53 to 52 weeks}
\description{Correction of data from 53 to 52 weeks a year
}
\usage{
    correct53to52(disProgObj, firstweek = 1)
}
\arguments{
\item{disProgObj}{object of class disProg (including the observed and the state chain).}
\item{firstweek}{the number of the first week in a year, default = 1 (if it starts
    with the beginning of a year). Necessary, because the infected of week 53
    and the infected of week 52 must be added.}
}
\value{
\item{disProg}{a object \code{disProg} (disease progress) including a list of the observed
    and the state chain (corrected to 52 weeks instead of 53 weeks a year)}
}
\details{\code{\link{readData}} reads data with 53 weeks a year, but normally one year is said
  to have 52 weeks.
}
\seealso{\code{\link{readData}}
}
\examples{
    #This call correct53to52 automatically
    obj <- readData("k1",week53to52=TRUE)
    correct53to52(obj) # first entry is the first week of the year

    obj <- readData("n1",week53to52=FALSE)
    correct53to52(obj, firstweek = 5) # now it's assumed that the fifth
                                      # entry is the first week of the year
}

%\keyword{}

<<echo=F>>=

# 'correct53to52' sums up and cuts a value from a splited last and first week of a year
#
# Parameter:
#       disProgObj - object of class disProgObj (including the observed and the state chain)
#       firstweek: the number in observed of the first week in a year, default = 1
# ouput:
#       disProgObj: the new disProgObj


correct53to52 <- function(disProgObj, firstweek = 1){

        if(firstweek > length(disProgObj$observed)){
                stop("firstweek doesn't exist")
        }

        observed <- disProgObj$observed
        state <- disProgObj$state

        if(length(state) != length(observed)){
                stop("state and observed don't have the same length")
        }

        # do not cut, if observed is too short
        length = length(observed[firstweek:length(observed)])

        if(length > 53){

                lastyear <- floor((length-1)/53)
                # sum case numbers of double weeks up
                for(i in 1:lastyear){
                        # last week of year i (-i+1 because the array now is shorter)
                        last <- firstweek + i * 52
                        # first week in year i+1
                        firstnew <- last + 1
                        observed[firstnew]  <- observed[last]  + observed[firstnew]
                        # delete double weeks
                        observed <- observed[-c(last)]

                        # with state
                        state[firstnew]  <- state[last]  + state[firstnew]
                        # delete double weeks
                        state <- state[-c(last)]
                }
        }

        # correct also the first week, if it doesn't is the beginning
        if(firstweek > 1){
                observed[firstweek] <- observed[firstweek] + observed[firstweek-1]
                observed <- observed[-c(firstweek-1)]
                state[firstweek] <- state[firstweek] + state[firstweek-1]
                state <- state[-c(firstweek-1)]
        }

        # correct all 2 to 1
        state[state==2] <- 1

        disProgObj$observed <- observed
        disProgObj$state <- state

        return(disProgObj)
}
@

\name{enlargeData}
\alias{enlargeData}
\title{Data Enlargement}
\description{Enlargement of data which is too short for a surveillance method to evaluate.
}
\usage{
    enlargeData(disProgObj, range = 1:156, times = 1)
}
\arguments{
\item{disProgObj}{object of class disProg (including the observed and the state chain).}
\item{range}{range of already existing data (\code{state}, \code{observed})
    which should be used for enlargement.}
\item{times}{number of times to enlarge.}
}
\value{
\item{disProg}{a object \code{disProg} (disease progress) including a list of the observed
    and the state chain (extended with cyclic data generation)}
}
\details{
        \code{observed} and \code{state} are enlarged in the way that the part \code{range}
        of \code{observed} and \code{state}
        is repeated \code{times} times in front of \code{observed} and \code{state}.
        Sometimes it's useful to care for the cyclic property of the timeseries, so as default
        we enlarge observed and state once with the first three existing years, assuming a year
        has 52 weeks.
}
\seealso{\code{\link{readData}}
}
\examples{
    obj <- readData("k1")

    enlargeData(obj) # enlarge once with part 1:156
    enlargeData(obj, 33:36, 10) # enlarge 10 times with part 33:36
}

%\keyword{}

<<echo=F>>=

enlargeData <- function(disProgObj, range = 1:156, times = 1){

        # enlarge observed
        disProgObj$observed <- c(rep(disProgObj$observed[range], times), disProgObj$observed)
        # enlarge state
        disProgObj$state <- c(rep(disProgObj$state[range], times), disProgObj$state)

        return(disProgObj)
}

