<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Temporal and Spatial Interaction Functions for twinstim — twinstim_iaf • surveillance</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Temporal and Spatial Interaction Functions for twinstim — twinstim_iaf"><meta name="description" content='A twinstim model as described in Meyer et al. (2012) requires
  the specification of the spatial and temporal interaction functions
  (\(f\) and \(g\), respectively),
  i.e. how infectivity decays with increasing spatial and temporal
  distance from the source of infection.
  Own such functions can be specified (see
  siaf and tiaf, respectively), but the
  package already predefines some common dispersal kernels returned by
  the constructor functions documented here.
  See Meyer and Held (2014) for various spatial interaction functions,
  and Meyer et al. (2017, Section 3, available as vignette("twinstim"))
  for an illustration of the implementation.'><meta property="og:description" content='A twinstim model as described in Meyer et al. (2012) requires
  the specification of the spatial and temporal interaction functions
  (\(f\) and \(g\), respectively),
  i.e. how infectivity decays with increasing spatial and temporal
  distance from the source of infection.
  Own such functions can be specified (see
  siaf and tiaf, respectively), but the
  package already predefines some common dispersal kernels returned by
  the constructor functions documented here.
  See Meyer and Held (2014) for various spatial interaction functions,
  and Meyer et al. (2017, Section 3, available as vignette("twinstim"))
  for an illustration of the implementation.'><!-- For Rd equations in pkgdown 2.1.0, see https://katex.org/docs/autorender.html --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"></script><script>
  document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
          throwOnError: false,
          macros: {"\\code": "\\texttt"}
      })
  });
</script></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">surveillance</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.24.1</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="../articles/pkgdown/overview.html">Overview</a></li>
<li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
<li class="nav-item"><a class="nav-link" href="../articles/pkgdown/events.html">Events</a></li>
<li class="nav-item"><a class="nav-link" href="../articles/pkgdown/bibliography.html">Bibliography</a></li>
      </ul><ul class="navbar-nav"></ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Temporal and Spatial Interaction Functions for <code>twinstim</code></h1>

      <div class="d-none name"><code>twinstim_iaf.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>A <code>twinstim</code> model as described in Meyer et al. (2012) requires
  the specification of the spatial and temporal interaction functions
  (\(f\) and \(g\), respectively),
  i.e. how infectivity decays with increasing spatial and temporal
  distance from the source of infection.
  Own such functions can be specified (see
  <code><a href="twinstim_siaf.html">siaf</a></code> and <code><a href="twinstim_tiaf.html">tiaf</a></code>, respectively), but the
  package already predefines some common dispersal kernels returned by
  the constructor functions documented here.
  See Meyer and Held (2014) for various spatial interaction functions,
  and Meyer et al. (2017, Section 3, available as <code>vignette("twinstim")</code>)
  for an illustration of the implementation.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="co"># predefined spatial interaction functions</span></span>
<span><span class="fu">siaf.constant</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">siaf.step</span><span class="op">(</span><span class="va">knots</span>, maxRange <span class="op">=</span> <span class="cn">Inf</span>, nTypes <span class="op">=</span> <span class="fl">1</span>, validpars <span class="op">=</span> <span class="cn">NULL</span><span class="op">)</span></span>
<span><span class="fu">siaf.gaussian</span><span class="op">(</span>nTypes <span class="op">=</span> <span class="fl">1</span>, logsd <span class="op">=</span> <span class="cn">TRUE</span>, density <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>              F.adaptive <span class="op">=</span> <span class="cn">FALSE</span>, F.method <span class="op">=</span> <span class="st">"iso"</span>,</span>
<span>              effRangeMult <span class="op">=</span> <span class="fl">6</span>, validpars <span class="op">=</span> <span class="cn">NULL</span><span class="op">)</span></span>
<span><span class="fu">siaf.exponential</span><span class="op">(</span>nTypes <span class="op">=</span> <span class="fl">1</span>, validpars <span class="op">=</span> <span class="cn">NULL</span>, engine <span class="op">=</span> <span class="st">"C"</span><span class="op">)</span></span>
<span><span class="fu">siaf.powerlaw</span><span class="op">(</span>nTypes <span class="op">=</span> <span class="fl">1</span>, validpars <span class="op">=</span> <span class="cn">NULL</span>, engine <span class="op">=</span> <span class="st">"C"</span><span class="op">)</span></span>
<span><span class="fu">siaf.powerlaw1</span><span class="op">(</span>nTypes <span class="op">=</span> <span class="fl">1</span>, validpars <span class="op">=</span> <span class="cn">NULL</span>, sigma <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu">siaf.powerlawL</span><span class="op">(</span>nTypes <span class="op">=</span> <span class="fl">1</span>, validpars <span class="op">=</span> <span class="cn">NULL</span>, engine <span class="op">=</span> <span class="st">"C"</span><span class="op">)</span></span>
<span><span class="fu">siaf.student</span><span class="op">(</span>nTypes <span class="op">=</span> <span class="fl">1</span>, validpars <span class="op">=</span> <span class="cn">NULL</span>, engine <span class="op">=</span> <span class="st">"C"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># predefined temporal interaction functions</span></span>
<span><span class="fu">tiaf.constant</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">tiaf.step</span><span class="op">(</span><span class="va">knots</span>, maxRange <span class="op">=</span> <span class="cn">Inf</span>, nTypes <span class="op">=</span> <span class="fl">1</span>, validpars <span class="op">=</span> <span class="cn">NULL</span><span class="op">)</span></span>
<span><span class="fu">tiaf.exponential</span><span class="op">(</span>nTypes <span class="op">=</span> <span class="fl">1</span>, validpars <span class="op">=</span> <span class="cn">NULL</span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>
    <p></p>
<dl><dt id="arg-knots">knots<a class="anchor" aria-label="anchor" href="#arg-knots"></a></dt>
<dd><p>numeric vector of distances at which the step function
    switches to a new height. The length of this vector determines the
    number of parameters to estimate. For identifiability, the step
    function has height 1 in the first interval \([0,knots_1)\). Note
    that the implementation is right-continuous, i.e., intervals are
    \([a,b)\).<br>
    An initial choice of knots could be based on quantiles of the
    observed distances between events and their potential source events.
    For instance, an identifiable spatial step function could be
    <code>siaf.step(quantile(<a href="epidataCS.html">getSourceDists</a>(myepi, "space"), c(1,2,4)/10))</code>,
    where <code>myepi</code> is the <code>"epidataCS"</code> data to be modelled.</p></dd>

  <dt id="arg-maxrange">maxRange<a class="anchor" aria-label="anchor" href="#arg-maxrange"></a></dt>
<dd><p>a scalar larger than any of <code>knots</code>.
    Per default (<code>maxRange=Inf</code>), the step function
    never drops to 0 but keeps the last height for any distance larger
    than the last knot. However, this might not work in some cases,
    where the last parameter value would become very small and lead to
    numerical problems. It is then possible to truncate
    interaction at a distance <code>maxRange</code> (just like what the
    variables <code>eps.s</code> and <code>eps.t</code> do in the
    <code>"<a href="epidataCS.html">epidataCS</a>"</code> object).</p></dd>

  <dt id="arg-ntypes">nTypes<a class="anchor" aria-label="anchor" href="#arg-ntypes"></a></dt>
<dd><p>determines the number of parameters ((log-)scales or (log-)shapes)
    of the kernels. In a multitype epidemic, the different types may
    share the same spatial interaction function, in which case
    <code>nTypes=1</code>. Otherwise <code>nTypes</code> should equal the number of
    event types of the epidemic, in which case every type has its own
    (log-)scale or (log-)shape, respectively.<br>
    Currently, <code>nTypes &gt; 1</code> is only implemented for
    <code>siaf.gaussian(F.adaptive = TRUE)</code>,
    <code>tiaf.step</code>, and <code>tiaf.exponential</code>.</p></dd>

  <dt id="arg-logsd-density">logsd,density<a class="anchor" aria-label="anchor" href="#arg-logsd-density"></a></dt>
<dd><p>logicals affecting the parametrization of the Gaussian kernel.
    Settings different from the defaults are deprecated.
    The default is to use only the kernel of the bivariate, isotropic
    normal distribution (<code>density=FALSE</code>, see Details below),
    parametrized with the log-standard deviation (<code>logsd=TRUE</code>) to
    avoid constrained optimisation (L-BFGS-B) or <code>validpars</code>.<br>
    The power-law kernels always employ the log-scale for their scale
    and shape parameters.</p></dd>

  <dt id="arg-f-adaptive-f-method">F.adaptive,F.method<a class="anchor" aria-label="anchor" href="#arg-f-adaptive-f-method"></a></dt>
<dd><p>If <code>F.adaptive = TRUE</code>, then an adaptive bandwidth of
    <code>adapt*sd</code> will be used in the midpoint-cubature
    (<code><a href="https://rdrr.io/pkg/polyCub/man/polyCub.midpoint.html" class="external-link">polyCub.midpoint</a></code> in package <span class="pkg">polyCub</span>)
    of the Gaussian interaction
    kernel, where <code>adapt</code> is an extra parameter of the returned
    <code>siaf$F</code> function and defaults to 0.1. It can be customized
    either by the <code>control.siaf$F</code> argument list of
    <code>twinstim</code>, or by a numeric specification of <code>F.adaptive</code>
    in the constructing call, e.g., <code>F.adaptive = 0.05</code> to achieve
    higher accuracy.<br>
    Otherwise, if <code>F.adaptive = FALSE</code>, the <code>F.method</code>
    argument determines which <code><a href="https://rdrr.io/pkg/polyCub/man/polyCub.html" class="external-link">polyCub</a></code> method to
    use in <code>siaf$F</code>. The accuracy (controlled via, e.g.,
    <code>nGQ</code>, <code>rel.tol</code>, or <code>eps</code>, depending on the cubature
    method) can then be adjusted in <code>twinstim</code>'s
    <code>control.siaf$F</code> argument.</p></dd>

  <dt id="arg-effrangemult">effRangeMult<a class="anchor" aria-label="anchor" href="#arg-effrangemult"></a></dt>
<dd><p>determines the effective range for numerical integration
    in terms of multiples of the standard deviation \(\sigma\) of the
    Gaussian kernel, i.e. with <code>effRangeMult=6</code>
    the \(6 \sigma\) region around the event is considered as
    the relevant integration domain instead
    of the whole observation region <code>W</code>.
    Setting <code>effRangeMult=NULL</code> will disable
    the integral approximation with an effective integration range.</p></dd>

  <dt id="arg-validpars">validpars<a class="anchor" aria-label="anchor" href="#arg-validpars"></a></dt>
<dd><p>function taking one argument, the parameter vector, indicating if it
    is valid (see also <code><a href="twinstim_siaf.html">siaf</a></code>).
    If <code>logsd=FALSE</code> and one prefers not to use
    <code>method="L-BFGS-B"</code> for fitting the <code>twinstim</code>, then
    <code>validpars</code> could be set to <code>function (pars) pars &gt; 0</code>.</p></dd>

  <dt id="arg-engine">engine<a class="anchor" aria-label="anchor" href="#arg-engine"></a></dt>
<dd><p>character string specifying the implementation to use.
    Prior to <span class="pkg">surveillance</span> 0.14.0, the <code>intrfr</code> functions for
    <code><a href="https://rdrr.io/pkg/polyCub/man/polyCub.iso.html" class="external-link">polyCub.iso</a></code> were evaluated in <span style="R">R</span> (and this
    implementation is available via <code>engine = "R"</code>).
    The new C-implementation, <samp>LinkingTo</samp> the newly exported
    <code>polyCub_iso</code> C-implementation in <span class="pkg">polyCub</span> 0.6.0,
    is considerably faster.</p></dd>

  <dt id="arg-sigma">sigma<a class="anchor" aria-label="anchor" href="#arg-sigma"></a></dt>
<dd><p>Fixed value of \(\sigma\) for the one-parameter power-law kernel.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>Evaluation of <code>twinstim</code>'s likelihood involves cubature of the
  spatial interaction function over polygonal domains. Various
  approaches have been compared by Meyer (2010, Section 3.2) and a new
  efficient method, which takes advantage of the assumed isotropy, has
  been proposed by Meyer and Held (2014, Supplement B, Section 2) for
  evaluation of the power-law kernels.
  These cubature methods are available in the dedicated <span style="R">R</span> package
  <span class="pkg">polyCub</span> and used by the kernels implemented in <span class="pkg">surveillance</span>.</p>
<p>The readily available spatial interaction functions are defined as
  follows:</p><dl><dt><code>siaf.constant</code>:</dt>
<dd><p>\(f(s) = 1\)</p></dd>

    <dt><code>siaf.step</code>:</dt>
<dd><p>\(f(s) = \sum_{k=0}^K \exp(\alpha_k) I_k(||s||)\),<br>
      where \(\alpha_0 = 0\), and \(\alpha_1, \dots, \alpha_K\) are
      the parameters (heights) to estimate. \(I_k(||s||)\) indicates
      if distance \(||s||\) belongs to the \(k\)th interval
      according to <code>c(0,knots,maxRange)</code>, where \(k=0\) indicates
      the interval <code>c(0,knots[1])</code>.<br>
      Note that <code>siaf.step</code> makes use of the <span class="pkg">memoise</span> package
      if it is available – and that is highly recommended to speed up
      calculations. Specifically, the areas of the intersection of a
      polygonal domain (influence region) with the “rings” of the
      two-dimensional step function will be cached such that they are
      only calculated once for every <code>polydomain</code> (in the first
      iteration of the <code>twinstim</code> optimization). They are used in
      the integration components <code>F</code> and <code>Deriv</code>.
      See Meyer and Held (2014) for a use case and further details.</p></dd>

    <dt><code>siaf.gaussian</code>:</dt>
<dd><p>\(f(s|\kappa) = \exp(-||s||/2/\sigma_\kappa^2)\)<br>
      If <code>nTypes=1</code> (single-type epidemic or type-invariant
      <code>siaf</code> in multi-type epidemic), then
      \(\sigma_\kappa = \sigma\) for all types \(\kappa\).
      If <code>density=TRUE</code> (deprecated), then the kernel formula above is
      additionally divided by \(2 \pi \sigma_\kappa^2\), yielding the
      density of the bivariate, isotropic Gaussian distribution with
      zero mean and covariance matrix \(\sigma_\kappa^2 I_2\).
      The standard deviation is optimized on the log-scale
      (<code>logsd = TRUE</code>, not doing so is deprecated).</p></dd>

    <dt><code>siaf.exponential</code>:</dt>
<dd><p>\(f(s) = exp(-||s||/sigma)\)<br>
      The scale parameter \(sigma\) is estimated on the log-scale,
      i.e., \(\sigma = \exp(\tilde{\sigma})\), and \(\tilde{\sigma}\)
      is the actual model parameter.</p></dd>

    <dt><code>siaf.powerlaw</code>:</dt>
<dd><p>\(f(s) = (||s|| + \sigma)^{-d}\)<br>
      The parameters are optimized on the log-scale to ensure positivity, i.e.,
      \(\sigma = \exp(\tilde{\sigma})\) and \(d = \exp(\tilde{d})\),
      where \((\tilde{\sigma}, \tilde{d})\) is the parameter vector.
      If a power-law kernel is not identifiable for the dataset at hand,
      the exponential kernel or a lagged power law are useful alternatives.</p></dd>

    <dt><code>siaf.powerlaw1</code>:</dt>
<dd><p>\(f(s) = (||s|| + 1)^{-d}\),<br>
      i.e., <code>siaf.powerlaw</code> with fixed \(\sigma = 1\).
      A different fixed value for \(sigma\) can be specified via the
      <code>sigma</code> argument of <code>siaf.powerlaw1</code>.
      The decay parameter \(d\) is estimated on the log-scale.</p></dd>

    <dt><code>siaf.powerlawL</code>:</dt>
<dd><p>\(f(s) = (||s||/\sigma)^{-d}\), for \(||s|| \ge \sigma\), and
      \(f(s) = 1\) otherwise,<br>
      which is a <em>L</em>agged power-law kernel featuring uniform
      short-range dispersal (up to distance \(\sigma\)) and a
      power-law decay (Pareto-style) from distance \(\sigma\) onwards.
      The parameters are optimized on the log-scale to ensure positivity, i.e.
      \(\sigma = \exp(\tilde{\sigma})\) and \(d = \exp(\tilde{d})\),
      where \((\tilde{\sigma}, \tilde{d})\) is the parameter vector.
      However, there is a caveat associated with this kernel: Its
      derivative wrt \(\tilde{\sigma}\) is mathematically undefined at
      the threshold \(||s||=\sigma\). This local non-differentiability
      makes <code>twinstim</code>'s likelihood maximization sensitive wrt
      parameter start values, and is likely to cause false convergence
      warnings by <code><a href="https://rdrr.io/r/stats/nlminb.html" class="external-link">nlminb</a></code>. Possible workarounds are to use
      the slow and robust <code>method="Nelder-Mead"</code>, or to just ignore
      the warning and verify the result by sets of different start values.</p></dd>

    <dt><code>siaf.student</code>:</dt>
<dd><p>\(f(s) = (||s||^2 + \sigma^2)^{-d}\),<br>
      which is a reparametrized \(t\)-kernel.
      For \(d=1\), this is the kernel of the Cauchy density with scale
      <code>sigma</code>. In Geostatistics, a correlation function of this
      kind is known as the Cauchy model.<br>
      The parameters are optimized on the log-scale to ensure
      positivity, i.e. \(\sigma = \exp(\tilde{\sigma})\) and
      \(d = \exp(\tilde{d})\), where \((\tilde{\sigma}, \tilde{d})\)
      is the parameter vector.</p></dd>


</dl><p>The predefined temporal interaction functions are defined as follows:</p><dl><dt><code>tiaf.constant</code>:</dt>
<dd><p>\(g(t) = 1\)</p></dd>

    <dt><code>tiaf.step</code>:</dt>
<dd><p>\(g(t) = \sum_{k=0}^K \exp(\alpha_k) I_k(t)\),<br>
      where \(\alpha_0 = 0\), and \(\alpha_1, \dots, \alpha_K\) are
      the parameters (heights) to estimate. \(I_k(t)\) indicates
      if \(t\) belongs to the \(k\)th interval
      according to <code>c(0,knots,maxRange)</code>, where \(k=0\) indicates
      the interval <code>c(0,knots[1])</code>.</p></dd>

    <dt><code>tiaf.exponential</code>:</dt>
<dd><p>\(g(t|\kappa) = \exp(-\alpha_\kappa t)\),<br>
      which is the kernel of the exponential distribution.
      If <code>nTypes=1</code> (single-type epidemic or type-invariant
      <code>tiaf</code> in multi-type epidemic), then
      \(\alpha_\kappa = \alpha\) for all types \(\kappa\).</p></dd>


</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>The specification of an interaction function, which is a list.
  See <code><a href="twinstim_siaf.html">siaf</a></code> and <code><a href="twinstim_tiaf.html">tiaf</a></code>, respectively, for a
  description of its components.</p>
    </div>
    <div class="section level2">
    <h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a></h2>
    <p>Meyer, S. (2010):
  Spatio-Temporal Infectious Disease Epidemiology based on Point Processes.
  Master's Thesis, Ludwig-Maximilians-Universität
  München.<br>
  Available as <a href="https://epub.ub.uni-muenchen.de/11703/" class="external-link">https://epub.ub.uni-muenchen.de/11703/</a></p>
<p>Meyer, S., Elias, J. and Höhle, M. (2012):
  A space-time conditional intensity model for invasive meningococcal
  disease occurrence. <em>Biometrics</em>, <b>68</b>, 607-616.
  <a href="https://doi.org/10.1111/j.1541-0420.2011.01684.x" class="external-link">doi:10.1111/j.1541-0420.2011.01684.x</a></p>
<p>Meyer, S. and Held, L. (2014):
  Power-law models for infectious disease spread.
  <em>The Annals of Applied Statistics</em>, <b>8</b> (3), 1612-1639.
  <a href="https://doi.org/10.1214/14-AOAS743" class="external-link">doi:10.1214/14-AOAS743</a></p>
<p>Meyer, S., Held, L. and Höhle, M. (2017):
  Spatio-temporal analysis of epidemic phenomena using the <span style="R">R</span> package
  <span class="pkg">surveillance</span>.
  <em>Journal of Statistical Software</em>, <b>77</b> (11), 1-55.
  <a href="https://doi.org/10.18637/jss.v077.i11" class="external-link">doi:10.18637/jss.v077.i11</a></p>
    </div>
    <div class="section level2">
    <h2 id="author">Author<a class="anchor" aria-label="anchor" href="#author"></a></h2>
    <p>Sebastian Meyer</p>
    </div>
    <div class="section level2">
    <h2 id="see-also">See also<a class="anchor" aria-label="anchor" href="#see-also"></a></h2>
    <div class="dont-index"><p><code><a href="twinstim.html">twinstim</a></code>, <code><a href="twinstim_siaf.html">siaf</a></code>, <code><a href="twinstim_tiaf.html">tiaf</a></code>,
  and package <span class="pkg">polyCub</span> for the involved cubature methods.</p></div>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="co"># constant temporal dispersal</span></span>
<span><span class="fu">tiaf.constant</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co"># step function kernel</span></span>
<span><span class="fu">tiaf.step</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">3</span>,<span class="fl">7</span><span class="op">)</span>, maxRange<span class="op">=</span><span class="fl">14</span>, nTypes<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="co"># exponential temporal decay</span></span>
<span><span class="fu">tiaf.exponential</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Type-dependent Gaussian spatial interaction function using an adaptive</span></span>
<span><span class="co"># two-dimensional midpoint-rule to integrate it over polygonal domains</span></span>
<span><span class="fu">siaf.gaussian</span><span class="op">(</span><span class="fl">2</span>, F.adaptive<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Single-type Gaussian spatial interaction function (using polyCub.iso)</span></span>
<span><span class="fu">siaf.gaussian</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Exponential kernel</span></span>
<span><span class="fu">siaf.exponential</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Power-law kernel</span></span>
<span><span class="fu">siaf.powerlaw</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Power-law kernel with fixed sigma = 1</span></span>
<span><span class="fu">siaf.powerlaw1</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># "lagged" power-law</span></span>
<span><span class="fu">siaf.powerlawL</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># (reparametrized) t-kernel</span></span>
<span><span class="fu">siaf.student</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># step function kernel</span></span>
<span><span class="fu">siaf.step</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">10</span>,<span class="fl">20</span>,<span class="fl">50</span><span class="op">)</span>, maxRange<span class="op">=</span><span class="fl">100</span><span class="op">)</span></span></code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Maintained by <a href="https://www.imbe.med.fau.de/person/sebastian-meyer" class="external-link">Sebastian Meyer</a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.9000. Hosted on <a href="https://R-forge.R-project.org/projects/surveillance/" class="external-link"><img src="https://r-forge.r-project.org/themes/rforge/imagesrf/logo.png" height="18" alt="R-Forge"></a></p>
</div>

    </footer></div>



  </body></html>

